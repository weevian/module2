{"version":3,"sources":["rooms.js"],"names":["conversation","type","tags","title","displayName","computedTitle","lastActivityDate","lastReadableActivityDate","lastRelevantActivityDate","roomInfo","id","lastSeenActivityDate","Date","toISOString","resolve","reject","buildRoomInfo","conversations","roomReadInfo","items","roomInfoPromises","push","all","then","roomInfoList","sort","a","b","buildRoomInfoList","debug","require","Rooms","SparkPlugin","extend","listen","spark","SDK_EVENT","EXTERNAL","RESOURCE","ROOMS","envelope","eventEnvelope","internal","mercury","connect","listenTo","INTERNAL","TEAMS_ACTIVITY","event","onWebexApiEvent","activity","data","verb","ACTIVITY_VERB","CREATE","roomCreatedEvent","getRoomEvent","EVENT_TYPE","CREATED","trigger","UPDATE","roomUpdatedEvent","UPDATED","sdkEvent","room","created","published","actorId","actor","entryUUID","ACTIVITY_FIELD","OBJECT","creatorId","lastActivity","TARGET","Error","isLocked","includes","ACTIVITY_TAG","LOCKED","e","logger","error","message","create","request","method","service","resource","body","res","get","options","qs","list","Page","listWithReadStatus","maxRecent","now","activitiesLimit","computeTitleIfEmpty","conversationsLimit","isActive","sinceDate","setDate","getDate","getWithReadStatus","roomId","convo","remove","statusCode","undefined","update"],"mappings":"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","file":"rooms.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {SparkPlugin, Page} from '@webex/webex-core';\nimport {cloneDeep} from 'lodash';\nimport {\n  ensureConvoAvailability,\n  SDK_EVENT,\n  createEventEnvelope,\n  buildHydraPersonId,\n  buildHydraRoomId,\n  getHydraRoomType,\n  deconstructHydraId\n} from '@webex/common';\n\nconst debug = require('debug')('memberships');\n\n/**\n * @typedef {Object} RoomObject\n * @property {string} id - (server generated) Unique identifier for the room\n * @property {string} title - The display name for the room. All room members\n * will see the title so make it something good\n * @property {string} teamId - (optional) The ID of the team to which the room\n * belongs\n * @property {isoDate} created - (server generated) The date and time that the\n * room was created\n */\n\n/**\n * Rooms are virtual meeting places for getting stuff done. This resource\n * represents the room itself. Check out the {@link Memberships} API to learn\n * how to add and remove people from rooms and the {@link Messages} API for\n * posting and managing content.\n * @class\n * @name Rooms\n */\nconst Rooms = SparkPlugin.extend({\n  /**\n   * Connect to the web socket to listen to incoming messages.\n   * @returns {Promise}\n   */\n  listen() {\n    return createEventEnvelope(this.spark, SDK_EVENT.EXTERNAL.RESOURCE.ROOMS)\n      .then((envelope) => {\n        this.eventEnvelope = envelope;\n\n        return this.spark.internal.mercury.connect().then(() => {\n          this.listenTo(this.spark.internal.mercury,\n            SDK_EVENT.INTERNAL.TEAMS_ACTIVITY,\n            (event) => this.onWebexApiEvent(event));\n        });\n      });\n  },\n\n  /**\n   * Trigger a membership related events.\n   * @param {Object} event\n   * @returns {undefined} -- nothing //linter requires return in JSDoc\n   */\n  onWebexApiEvent(event) {\n    const {activity} = event.data;\n\n    /* eslint-disable no-case-declarations */\n    switch (activity.verb) {\n      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:\n        const roomCreatedEvent =\n          this.getRoomEvent(activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);\n\n        if (roomCreatedEvent) {\n          debug(`room \"created\" payload: \\\n            ${JSON.stringify(roomCreatedEvent)}`);\n          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, roomCreatedEvent);\n        }\n        break;\n\n      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.UPDATE:\n        const roomUpdatedEvent =\n          this.getRoomEvent(activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);\n\n        if (roomUpdatedEvent) {\n          debug(`room \"updated\" payload: \\\n            ${JSON.stringify(roomUpdatedEvent)}`);\n          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, roomUpdatedEvent);\n        }\n        break;\n\n      default:\n        break;\n    }\n  },\n\n  /**\n   * Constructs the data object for an event on the rooms resource,\n   * adhering to Hydra's Webehook data structure.\n   * @param {Object} activity from mercury\n   * @param {Object} event type of \"webhook\" event\n   * @returns {Object} constructed event\n   */\n  getRoomEvent(activity, event) {\n    try {\n      const sdkEvent = cloneDeep(this.eventEnvelope);\n      let room;\n\n      sdkEvent.event = event;\n      sdkEvent.data.created = activity.published;\n      sdkEvent.actorId = buildHydraPersonId(activity.actor.entryUUID);\n      if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED) {\n        room = SDK_EVENT.INTERNAL.ACTIVITY_FIELD.OBJECT;\n        sdkEvent.data.creatorId = buildHydraPersonId(activity.actor.entryUUID);\n        sdkEvent.data.lastActivity = activity.published;\n      }\n      else if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED) {\n        room = SDK_EVENT.INTERNAL.ACTIVITY_FIELD.TARGET;\n        // TODO - lastActivity is not in the mercury 'update' event\n        // would need to make an async call to get more conversation details\n        // or we can skip this for the SDK, since we will provide an\n        // SDK api to allow the app to query this directly if it needs\n        // sdkEvent.data.lastActivity = 'to do';\n      }\n      else {\n        throw new Error('unexpected event type');\n      }\n      sdkEvent.data.id =\n      buildHydraRoomId(activity[room].id);\n      sdkEvent.data.type = getHydraRoomType(activity[room].tags);\n      sdkEvent.data.isLocked =\n        activity[room].tags.includes(SDK_EVENT.INTERNAL.ACTIVITY_TAG.LOCKED);\n\n      return sdkEvent;\n    }\n    catch (e) {\n      this.spark.logger.error(`Unable to generate SDK event from mercury \\\n'socket activity for rooms:${event} event: ${e.message}`);\n\n      return null;\n    }\n  },\n\n  /**\n   * Creates a new room. The authenticated user is automatically added as a\n   * member of the room. See the {@link Memberships} API to learn how to add\n   * more people to the room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * ciscospark.rooms.create({title: 'Create Room Example'})\n   *   .then(function(room) {\n   *     var assert = require('assert')\n   *     assert(typeof room.created === 'string');\n   *     assert(typeof room.id === 'string');\n   *     assert(room.title === 'Create Room Example');\n   *     console.log(room.title);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  create(room) {\n    return this.request({\n      method: 'POST',\n      service: 'hydra',\n      resource: 'rooms',\n      body: room\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Returns a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @param {Object} options\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * ciscospark.rooms.create({title: 'Get Room Example'})\n   *   .then(function(r) {\n   *     room = r\n   *     return ciscospark.rooms.get(room.id)\n   *   })\n   *   .then(function(r) {\n   *     var assert = require('assert');\n   *     assert.deepEqual(r, room);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  get(room, options) {\n    const id = room.id || room;\n\n    return this.request({\n      service: 'hydra',\n      resource: `rooms/${id}`,\n      qs: options\n    })\n      .then((res) => res.body.items || res.body);\n  },\n\n  /**\n   * Returns a list of rooms. In most cases the results will only contain rooms\n   * that the authentiated user is a member of.\n   * @instance\n   * @memberof Rooms\n   * @param {Object} options\n   * @param {Object} options.max Limit the maximum number of rooms in the\n   * response.\n   * @returns {Promise<Page<RoomObject>>}\n   * @example\n   * var createdRooms;\n   * Promise.all([\n   *   ciscospark.rooms.create({title: 'List Rooms Example 1'}),\n   *   ciscospark.rooms.create({title: 'List Rooms Example 2'}),\n   *   ciscospark.rooms.create({title: 'List Rooms Example 3'})\n   * ])\n   *   .then(function(r) {\n   *     createdRooms = r;\n   *     return ciscospark.rooms.list({max: 3})\n   *       .then(function(rooms) {\n   *         var assert = require('assert');\n   *         assert(rooms.length === 3);\n   *         for (var i = 0; i < rooms.items.length; i+= 1) {\n   *           assert(createdRooms.filter(function(room) {\n   *             return room.id === rooms.items[i].id;\n   *           }).length === 1);\n   *         }\n   *         return 'success';\n   *       });\n   *   });\n   *   // => success\n   */\n  list(options) {\n    return this.request({\n      service: 'hydra',\n      resource: 'rooms/',\n      qs: options\n    })\n      .then((res) => new Page(res, this.spark));\n  },\n\n  /**\n   * Returns a list of rooms with details about the data of the last\n   * actvity in the room, and the date of the users last presences in\n   * the room. The list is sorted with this with most recent activity first\n   *\n   * For rooms where lastActivityDate > lastSeenDate the space\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.list() function in the following ways:\n   *  -- when called with no parameters it returns an array of all\n   *     spaces, up to 1000, that the user is a member of\n   *  -- pagination is not supported. ALL rooms are returned which\n   *     can result in a large payload\n   *  -- For users with hundreds of spaces, this API can take some time to\n   *     to return, for this reason it supports an optional maxRecent parameter.\n   *     If set this will return only the specified number of spaces with activity\n   *     in the last two weeks.  Reccomended value is 30.  Max supported is 100.\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available for each room in the list\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general this function should be used only when the client needs to\n   * access read status info, for example on startup.\n   * After startup, clients should track message and membership:seen events\n   * to maintain read status client side.\n   *\n   * Since this API can take some time to return up to 1000 spaces, it is\n   * recommended that custom clients call this first with the maxRecent parameter\n   * set to 30, so that they can display some of the more recents spaces.  Calling\n   * this API a second time with no parameters will return all the spaces.\n   *\n   * Not all spaces may be returned, for example when users in more than 1000\n   * spaces, or when a new spaces is added after this function is called,\n   * but before it returns. Custom clients should be prepared to gracefully\n   * andle cases where an event occurs in a space not returned by this call,\n   * by querying rooms.getWithReadStatus() with the id of the room in question\n   *\n   * This function may be deprecated when this info is provided in the membership\n   * objects returned in the list function.\n   * @instance\n   * @param {int} maxRecent\n   * @memberof Rooms\n   * @returns {Promise<RoomInfoObjectList>}\n   */\n  async listWithReadStatus(maxRecent = 0) {\n    const now = new Date();\n    const options = {\n      activitiesLimit: 0,\n      computeTitleIfEmpty: true,\n      conversationsLimit: 1000,\n      isActive: true\n    };\n\n    if (maxRecent > 0) {\n      options.conversationsLimit = maxRecent;\n      options.sinceDate = now.setDate(now.getDate() - 14);\n    }\n    else if ((maxRecent < 0) || (maxRecent > 100)) {\n      return Promise.reject(new Error('rooms.listWithReadStatus: ' +\n        'optional maxRecent parameter must be an integer between 1 and 100'));\n    }\n\n    return ensureConvoAvailability(this.spark)\n      .then(() => this.spark.internal.conversation.list(options))\n      .then((conversations) => buildRoomInfoList(conversations));\n  },\n\n  /**\n   * Returns a single room object with details about the data of the last\n   * actvity in the room, and the date of the users last presence in\n   * the room.\n   *\n   * For rooms where lastActivityDate > lastSeenDate the room\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.get() function in the following ways:\n   *  -- it takes a single roomId parameter to fetch\n   *  -- no other options are considered\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available in the return object\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general clients should use the listWithReadStatus() method on startup\n   * to get the initial roomStatus and then update their client side copy by\n   * responding to message, membership and room events.\n\n   * This function allows a custom client to be \"nimble\" if it is responding\n   * to an event with a roomId that was not in the original fetch.  The\n   * anticipated behavior is that getWithReadStats is called \"just in time\",\n   * with the resulting room object being added to the list of cached room\n   * objects on the client side.\n   *\n   * This function may be deprecated when this info is provided in the room\n   * object returned in the get function.\n   * @instance\n   * @memberof Rooms\n   * @param {string} roomId\n   * @returns {Promise<RoomInfoObject>}\n   */\n  getWithReadStatus(roomId) {\n    const conversation = {\n      id: deconstructHydraId(roomId).id\n    };\n\n    return ensureConvoAvailability(this.spark)\n      .then(() => this.spark.internal.conversation.get(conversation,\n        {\n          computeTitleIfEmpty: true,\n          activitiesLimit: 0 // don't send the whole history of activity\n        })\n        .then((convo) => buildRoomInfo(convo)));\n  },\n\n  /**\n   * Deletes a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @returns {Promise}\n   * @example\n   * var room;\n   * ciscospark.rooms.create({title: 'Remove Room Example'})\n   *  .then(function(r) {\n   *    room = r;\n   *    return ciscospark.rooms.remove(room.id);\n   *  })\n   *  .then(function() {\n   *    return ciscospark.rooms.get(room.id);\n   *  })\n   *  .then(function() {\n   *    var assert = require('assert');\n   *    assert(false, 'the previous get should have failed');\n   *  })\n   *  .catch(function(reason) {\n   *    var assert = require('assert');\n   *    assert.equal(reason.statusCode, 404);\n   *    return 'success'\n   *  });\n   *  // => success\n   */\n  remove(room) {\n    const id = room.id || room;\n\n    return this.request({\n      method: 'DELETE',\n      service: 'hydra',\n      resource: `rooms/${id}`\n    })\n      .then((res) => {\n        // Firefox has some issues with 204s and/or DELETE. This should move to\n        // http-core\n        if (res.statusCode === 204) {\n          return undefined;\n        }\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Used to update a single room's properties.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * ciscospark.rooms.update({title: 'Update Room Example'})\n   *   .then(function(r) {\n   *     room = r;\n   *     room.title = 'Update Room Example (Updated Title)';\n   *     return ciscospark.rooms.update(room);\n   *   })\n   *   .then(function() {\n   *     return ciscospark.rooms.get(room.id);\n   *   })\n   *   .then(function(room) {\n   *    var assert = require('assert');\n   *     assert.equal(room.title, 'Update Room Example (Updated Title)');\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  update(room) {\n    const {id} = room;\n\n    return this.request({\n      method: 'PUT',\n      service: 'hydra',\n      resource: `rooms/${id}`,\n      body: room\n    })\n      .then((res) => res.body);\n  }\n});\n\nexport default Rooms;\n\n/**\n * Helper method to build a roomInfo object from a conversation object\n * @param {Conversation~ConversationObject} conversation\n * @returns {Promise<RoomInfoObject>}\n */\nasync function buildRoomInfo(conversation) {\n  try {\n    const type = getHydraRoomType(conversation.tags);\n    const title = conversation.displayName ?\n      conversation.displayName : conversation.computedTitle;\n    const lastActivityDate = conversation.lastReadableActivityDate ?\n      conversation.lastReadableActivityDate :\n      conversation.lastRelevantActivityDate;\n\n    const roomInfo = {\n      id: buildHydraRoomId(conversation.id),\n      type,\n      ...(title && {title: conversation.displayName}),\n      ...(lastActivityDate && {lastActivityDate}),\n      lastSeenActivityDate: conversation.lastSeenActivityDate ?\n        conversation.lastSeenActivityDate :\n        // If user has never been seen set the date to \"a long time ago\"\n        new Date(0).toISOString()\n    };\n\n    return Promise.resolve(roomInfo);\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Helper method to build a list of roomInfo object from conversation list\n * @param {Conversation~ConversationObjectList} conversations\n * @returns {Promise<RoomInfoList>}\n */\nasync function buildRoomInfoList(conversations) {\n  // Convert each Conversation into a roomInfo object\n  const roomReadInfo = {items: []};\n  const roomInfoPromises = [];\n\n  for (const conversation of conversations) {\n    roomInfoPromises.push(buildRoomInfo(conversation));\n  }\n\n  return Promise.all(roomInfoPromises)\n    .then((roomInfoList) => {\n      roomReadInfo.items = roomInfoList;\n      roomReadInfo.items.sort((a, b) => (a.lastActivityDate < b.lastActivityDate ? 1 : -1));\n\n      return roomReadInfo;\n    });\n}\n"]}